import sqlite3

SCHEMA = """
-- artists
CREATE TABLE artists (
    artist_id TEXT PRIMARY KEY,
    name TEXT UNIQUE,
    genre TEXT,
    followers INTEGER
);

-- tracks
CREATE TABLE tracks (
    track_id TEXT PRIMARY KEY,
    artist_id TEXT,
    track_name TEXT,
    album_name TEXT,
    release_year INTEGER,
    FOREIGN KEY(artist_id) REFERENCES artists(artist_id)
);

-- features
CREATE TABLE features (
    track_id TEXT PRIMARY KEY,
    danceability REAL,
    energy REAL,
    tempo REAL,
    valence REAL,
    FOREIGN KEY(track_id) REFERENCES tracks(track_id)
);

-- last.fm
CREATE TABLE lastfm (
    track_id TEXT PRIMARY KEY,
    playcount INTEGER,
    listeners INTEGER,
    top_tag TEXT,
    FOREIGN KEY(track_id) REFERENCES tracks(track_id)
);
"""

import requests
import time
import base64

def get_spotify_token(client_id, client_secret):
    # Input:
    #   client_id (str)
    #   client_secret (str)
    # Output:
    #   token (str) - Bearer access token
    url = "https://accounts.spotify.com/api/token"
    auth_str = f"{client_id}:{client_secret}"
    b64_auth = base64.b64encode(auth_str.encode('ascii')).decode('ascii')
    headers = {'Authorization': 'Basic ' + b64_auth}
    data = {'grant_type': 'client_credentials'}
    auth_response = requests.post(url, data=data, headers=headers)
    auth_response.raise_for_status()
    return auth_response.json().get('access_token')

# function to get Spotify API token

def get_spotify_tracks(query, token, limit=25):
    # Input:
    #   query (str) - Search query
    #   token (str) - Bearer access token
    #   limit (int) - Number of results to return
    # Output:
    #   tracks (list) - List of track dictionaries
    headers = {"Authorization": f"Bearer {token}"}
    url = "https://api.spotify.com/v1/search"
    params = {
        "q": query,
        "type": "track",
        "limit": min(limit, 25)
    }

    response = requests.get(url, headers=headers, params=params).json()

    tracks = []
    for item in response["tracks"]["items"]:
        album = item["album"]
        year = int(album["release_date"].split("-")[0])
        artist = item["artists"][0]

        tracks.append({
            "track_id": item["id"],
            "track_name": item["name"],
            "artist_name": artist["name"],
            "artist_id": artist["id"],
            "album_name": album["name"],
            "release_year": year,
            "primary_genre": None
        })
    return tracks
#function to search for tracks


def get_spotify_audio_features(track_ids, token):
    # Input:
    #   track_ids (list) - List of Spotify track IDs
    #   token (str) - Bearer access token
    # Output:
    #   features (dict) - Dictionary mapping track_id to features dictionary
    headers = {"Authorization": f"Bearer {token}"}
    url = "https://api.spotify.com/v1/audio-features"
    features = {}

    for i in range(0, len(track_ids), 100):
        batch_ids = track_ids[i:i+100]
        params = {"ids": ",".join(batch_ids)}
        response = requests.get(url, headers=headers, params=params).json()

        for item in response["audio_features"]:
            if item:
                features[item["id"]] = {
                    "danceability": item["danceability"],
                    "energy": item["energy"],
                    "tempo": item["tempo"],
                    "valence": item["valence"]
                }
    return features


def get_lastfm_track_info(artist, track, api_key):
    # Input:
    #   artist (str) - Artist name
    #   track (str) - Track name
    #   api_key (str) - Last.fm API key
    # Output:
    #   info (dict) - Dictionary with playcount, listeners, top_tag
    url = "http://ws.audioscrobbler.com/2.0/"
    params = {
        "method": "track.getInfo",
        "api_key": api_key,
        "artist": artist,
        "track": track,
        "format": "json"
    }

    response = requests.get(url, params=params).json()

    if "track" in response:
        track_info = response["track"]
        playcount = int(track_info["playcount"])
        listeners = int(track_info["listeners"])
        top_tag = None
        if "toptags" in track_info and track_info["toptags"]["tag"]:
            top_tag = track_info["toptags"]["tag"][0]["name"]

        return {
            "playcount": playcount,
            "listeners": listeners,
            "top_tag": top_tag
        }
    else:
        return {
            "playcount": 0,
            "listeners": 0,
            "top_tag": None
        }

